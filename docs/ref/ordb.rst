ORDB: Data Model Layer
======================

ORDB is ORDeC's data model layer.

We need some way to represent and work with design data (e.g. schematics, symbols, layouts, simulation results, extraction results, DRC \& LVS results). How should this look like?

Each design flow step produces a set of interrelated design objects. For example, a step might return a schematic that consists of nets, ports, drawn wires and instantiated symbols. This can be seen as a graph, with the design objects as nodes and the references between them as edges. Some of the edges might be between nodes generated by the specific step, while some edges might link to nodes generated by previous steps. The newly generated nodes form a distinct subgraph, and references to previouly generated nodes can be seen linking the subgraph to other subgraphs.

ORDB provides a data model based on this idea of subgraphs that adheres to the following five principles:

1. **Schema-based:** ORDB design data must conform to some a predefined schema. This schema primarily defines a set of node types (tables) with specific attributes (columns). The schema also defines possible relations between nodes.

  - Attributes must be hashable, which means that lists and dicts cannot be attributes. Attributes are typically either primitive types (e.g. string, int, Vec2R) or immutable subgraph references. An exception is the "cell" attribute.

3. **Relational queries:**
  
  - In a 1:n relation, if we add a reference on one side, we want to be able to efficiently access the reference in the opposite direction.
  - For this, we need transparent indices.
  - Integrity checks ("foreign keys").
  - ORDB can loosely be seen as relational database.

3. **Hierarchical tree organization:** Names can be assigned to nodes. Those names can be arranged hierarchically in a tree. This makes it possible to group design objects in arrays, structs or other logical units.
4. **Persistent data structure:** ORDB subgraphs are based on `persistent data structures <https://en.wikipedia.org/wiki/Persistent_data_structure>`_.

  - The state of a subgraph is immutable.
  - Modifying a subgraph (i.e. adding, updating or removing nodes) replaces its old state with a new state (that is built upon the previous state). The old subgraph state remains unchanged.
  - Logical copies of subgraphs are free, as the underlying data structures are immutable and thus do not need to be copied.
  - Using this mechanism, similar subgraphs can share data.

5. **Mutable and immutable interfaces:**
   
  - While creating or transforming a subgraph, a mutable interface is used, hiding the aforementioned immutability and persistence.
  - At functional boundaries, subgraphs are made immutable (frozen). This ensures that subsequent use of the subgraph is read-only and does not accidentally modify it. It also and allows caching of return values -- for example, we can generate a Symbol once and then use it at many occasions.

ORDB is primarily intended as **in-memory** database. Serialization and network support is planned but not currently implemented.

As potential alternatives to ORDB, some other ideas were considered but discarded:

- A in-memory global relational database could be used within the context of running the design tool / concerning one IC design. Such a system would be *schema-based* and offer *relational queries*, but it would not provide a *persistent data structure* and *mutable and immutable interfaces* on subgraph level.
- ORDeC's old data model layer was *schema-based* and had *mutable and immutable interfaces*, but lacked *persistency* and *relational queries*.
- Plain Python objects, frozen dataclasses or similar approaches mainly lack *persistency*, the ability to have *mutable and immutable interfaes* on subgraph level and *relational queries*.

Why persistency?
----------------

Subgraphs with high degrees of similarity should share memory:
    
- Example 1: very similar symbols (e.g. resistors with different values) each have separate, but almost identical subgraphs in memory (only caption changed)
- Example 2: When evolving a schematic for cross-technology mapping, we either have to work on a copy of the original schematic, or make sure the original schematic reference is never used (else we would lose the functional encapsulation)!
- Example 3: Similarly, stuff like placement or routing are steps that evolve layouts.
- Example 4: Separate copies of the SimHierarchy when performing multiple simulations (e.g. parameter sweep, monte carlo, op+transient, ...)

Other thoughts:

- Ability to cheaply maintain various incremental versions/copies of design data.
- Full functional encapsulation, results of functions are immutable and can be cached.
- Revert changes cheaply and without adding software complexity above DB layer!
- In principle, stuff like PNR could be done in parallel with different parameters, and then the best solution can be used.
- Merge: 'divergent' copies of one cell can also be merged at the database layer
    
  - Example 1: parallel parasitic extraction
  - Example 2: parallel monte-carlo simulation
  - (problem 1: id collision, problem 2: modifications to same id)

Persistency is implemented using `Pyrsistent <https://pyrsistent.readthedocs.io/>`_.

Reference
---------

Further remarks:

- Every node has a node ID (nid) that identifies it uniquely within its subgraph. Both nodes inside the subgraph and nodes in other subgraphs use this nid to reference the node.
- Nodes can only references immutable subgraphs. For this reason, subgraphs form a a directed acyclic graph.
- The access layer (Cursor) is separate from the stored data (Node).
- There are two ways to build upon an immutable subgraph:
  
  - Thaw + modify the subgraph (add and update nodes).
  - Keep the subgraph immutable, create a new subgraph that references it.

.. automodule:: ordec.ordb
  :member-order: bysource
  :members:

.. .. autoclass:: Cell
..    :members:
..    :exclude-members: __init__

.. .. autoclass:: Node
..    :members:
..    :exclude-members: Children, __init__

.. .. autoclass:: View
..    :members:
